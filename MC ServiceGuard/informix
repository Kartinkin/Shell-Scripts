#!/usr/bin/sh
# Version	2.1
# Date		27 May 99
# Author	Kirill Kartinkin

# Управляющая программа кластерного сервиса, представленного СУБД INFORMIX.
# Работа программы гарантирована с СУБД версий 7.xx. Доподлинно известно,
# что она не поддерживает INFORMIX старше версии 7.
#
# Внимание! Данная программа работает только совместно с MC/ServiceGuard и
# только в рамках пакета. Более того, она использует нестандартные возможности
# программы управления пакетом (написанные автором) и может работать только в
# такой расширенной среде.
# Программу требуется запускать от имени пользователя root.
#
# Внимание! Программа не способна обрабатывать уменьшение числа виртуальных
# процессоров СУБД. Данное административное действие приравнивается к сбою в
# работе СУБД и фиксируеся ошибка.
#
# При запуске программы производятся последовательно следующие действия:
#	Подключаются все необходимые конфигурационные файлы.
#	Запускается СУБД INFORMIX Server в режиме On-Line.
#	Запускается архивирование логических журналов командой
#		"~informix/scripts/backup.sh startll".
#	Начинается слежение за работой СУБД.
# Если какие-либо процессы СУБД вдруг исчезли, программа пытается
# остановить INFORMIX и, в случае неудачи, убивает оставшиеся процессы.
#
# Когда программа получает сигнал TERM, производится перевод СУБД в режим
# Off-Line и, в случае неудачи, убиваются оставшиеся процессы.
#
# Параметры:
#	нет
#
# Возвращаемые значения:
#	0	O.K.
#	2	INFORMIX не запушен
#	3	INFORMIX остановить не удалось, процессы убиты
#	4	INFORMIX свалился сразу после старта
#	5	INFORMIX свалился во время работы
#	10	Сигнал на останов пришел слишком рано
#	101	Ошибка подключения вспомогательных файлов
#

################################################################################
# Описываем переменные конфигурации и производим необходимые проверки

# Переменная содержит период (в секундах) проверки состояния СУБД.
MONITOR_INTERVAL=300

# Переменная задает имя процесса, образующего СУБД
# Для OnLine Dynamic Server 7.xx переменная должна содержать oninit.
MONITOR_PROCESS=oninit

# Промежуток времени (в секундах) в течениии которого мы ждем завершения
# работы СУБД после подачи команды 'onmdoe -ky'
# По истечении заданного времени процессы СУБД убиваются.
#
# Внимание! Данное значение должно быть на две минуты меньше таймаута,
# установленноко в конфигурации пакета для этого сервиса.
TIME_OUT=240

# Устанавливаем необходимые пути поиска
PATH=/sbin:/usr/sbin:/usr/bin

# Извлекаем из командной строки имя программы
Name=${0##*/}

# Внимание! Для работы программы необходимы следующие файлы:
set -A FilesToSource \
	~informix/.environment \
	/etc/cmcluster/depo/depo.environment \
	/var/adm/bin/logger.sh
	
# В файле ~informix/.environment содержатся все необходимые
# администратору СУБД переменные окружения.
#	INFORMIXDIR
#	INFORMIXSERVER
#	ONCONFIG

# В файле /etc/cmcluster/depo/depo.environment содержатся
# переменные окружения для сервсов.
#	LOCK_FILE
#	PACKAGE_FACILITY
#	PACKAGE_TAG
#	PACKAGE_LOG_PS

# Файле /var/adm/bin/logger.sh содержит функцию Logger
# Следующие переменные необходимы для описания этой функции.
# При описании используем одинарные кавычки, чтобы передать имя переменной
# окружения, а не ее значение.
LOGGER_FACILITY='${PACKAGE_FACILITY}'
LOGGER_TAG='${PACKAGE_TAG}'

# Добавляем указанные выше файлы
for File in ${FilesToSource[*]}
do
	if [[ -f ${File} ]]
	then
		. ${File}
	else
		print "${Name}:\tERROR: Unnable to source ${File}"
		exit 101
	fi
done

################################################################################
################################################################################
# Описываем вспомогательные функции

################################################################################
# Функция создает файл блокировоки.
# Данный файл никак не используется внутри программы, но помогает программе
# управления пакетом реализовать последовательный старт (останов) сервисов.
#
# Параметры:
#	нет
#
# Возвращаемые значения:
#	0 -- файл создан
#	1 -- ошибка при создадии
#	2 -- ошибка, переменная LOCK_FILE═не описана
# Используемые внешние переменные:
#	LOCK_FILE
#
function Touch_lock
{
	if [[ -z ${LOCK_FILE} ]]
	then
		Logger warning "Variable 'LOCK_FILE' was not set."
		return 2
	else
		touch ${LOCK_FILE}
		if (( $? != 0 ))
		then
			Logger err "Unnable to create \"${LOCK_FILE}\"."
			return 1
		fi
		print "Starting INFORMIX OnLine Dynamic Server, please wait...\nDO NOT remove this file manually." >${LOCK_FILE}
		return 0
	fi
}

################################################################################
# Функция удаляет файл LOCK_FILE.
# Используется для реализации последовательного старта (останова) сервисов.
#
# Параметры:
#	нет
#
# Возвращаемые значения:
#	0 -- файл удален
#	1 -- ошибка при удалении
#
# Используемые внешние переменные:
#	LOCK_FILE
#
function RemoveLock
{
	if [[ -f ${LOCK_FILE} ]]
	then
		rm -f ${LOCK_FILE} >/dev/null 2>&1
		if [[ -f ${LOCK_FILE} ]]
		then
			Logger err "Unnable to remove \"${LOCK_FILE}\"."
			return 1
		fi
	fi
	return 0
}

################################################################################
# Функция удаляет файл блокировок перед выходом
#
# Параметры:
#	$1 -- код возврата
#
# Возвращаемые значения:
#	нет
#
function Exit
{
	Remove_lock
	exit $1
}

################################################################################
################################################################################
# Функция для запуска сервиса

################################################################################
# Функция стартует INFORMIX OnLine Dynamic Server версии 7.xx в режим On-Line.
# После успешного старта начинается архивирование логических журналов.
# Кроме того, функция готовит список OLD_PROCESSES_PID, используемый
# после в функции Monitor_processes.
#
# Параметры:
#	нет
#
# Возвращаемые значения:
#	0 -- СУБД запущена
#	если запуск СУБД невозможен, вызывается функция Exit
#
# Изменяемые внешние переменные:
#	OLD_PROCESSES_PID
function Start_INFORMIX
{
	# Устанавливаем блокировку
	Touch_lock

	Logger info "Starting INFORMIX..."

	# Далее мы будем производить наблюдение за СУБД по pid'ам процессов,
	# а пока запоминаем уже существующие процессы других экземпляров СУБД.
	# Заполняем массив OLD_PROCESSES_PID
	OLD_PROCESSES_PID=$(ps -u informix | awk -v Name="${MONITOR_PROCESS}"\
		'$4~"^"Name"$" { print $1 }')
	# Удаляем символы '\n' из строки
	OLD_PROCESSES_PID=$(print ${OLD_PROCESSES_PID})

	# Поскольку мы уже загрузили настройки пользователя informix,
	# делаем su без "-"
	su informix -c "${INFORMIXDIR}/bin/${MONITOR_PROCESS}"
	if (( $? != 0 ))
	then
		# Ошибка СУБД не запустилась
		Logger err "Informix NOT started!"
		Exit 2
	else
		Logger info "Informix started!"
	fi
	sleep 3

	# Ни в коем случае не запускаем архивирование логических журналов,
	# т.к. можем затереть предыдущую ленту.
	#su informix -c "~informix/scripts/backup.sh startll"

	# Запускаем сборщик статистики onprobe
	#Logger debug "Starting data collector..."
	#su informix -c "${INFORMIXDIR}/bin/onprobe"
	
	# Удаляем файл блокировки
	Remove_lock
	return 0
}

################################################################################
################################################################################
# Функции для останова сервиса

################################################################################
# Процедура переводит СУБД INFORMIX OnLine Dynamic Server версии 7.xx
# в состояние Off-Line. Перед остановом прерывается архивирование логических
# журналов. Если за определенные период времени СУБД не остановилась,
# ее процессы убиваются наиболее коректным способом.
#
# Параметры:
#	$1 -- код возврата (позволяет указать в какой ситуации вызвали функцию).
#		Если параметр не указан, код возврата становится 0.
#		Отличное от нуля значение говорит о сбое в работе СУБД и
#		необходимости аварийной остановки
#
# Возвращаемые значения:
#	процедура не возвращает управление, она вызывает процедуру Exit
#	передавая ей значение параметра $1 или 0, если последний не указан.
#
# Используемае внешние функции:
#	PACKAGE_LOG_PS
#
# Используемые внешние переменные:
#	MONITOR_PROCESSES_PID -- заполняется функцией Monitor_processes
#
function Halt_INFORMIX
{
	# Проверяем параметр и устанавливаем код возврата
	if [[ -z $1 ]]
	then
		RetValue = 0
	else
		RetValue = $1
	fi
	
	# Проверяем, создан ли список процессов (может случится так, что
	# сигнал TERM получен до заполнения массива).
	if [[ -z ${MONITOR_PROCESSES_PID[*]} ]]
	then
		exit 10
	fi

	# Устанавливаем блокировку
	Touch_lock

	# Прераваем архивирование логических журналов
	su informix -c "~informix/scripts/backup.sh stopll"

	# Останавливаем все известные системы мониторинга:
	# ... oncockpit
	Logger debug "Halting oncockpit..."
	kill $(ps -u informix | \
		awk '$4~"^oncockpit$" { print $1 }') >/dev/null 2>&1
	# ... onprobe
	Logger debug "Halting data collector..."
	set -A OnProvePIDs $(ps -u informix | awk '$4~"^onprobe$" { print $1 }')
	kill $(onstat -g ses | awk -v OnProbePIDs="${OnProbePIDs}"\ 
			'match (" "OnProbePIDs" " , " "$4" ") != 0
				{ print $4 }
		') >/dev/null 2>&1
	# ... onperf
	Logger debug "Halting onperf..."
	kill $(ps -u informix | awk '$4~"^onperf$" { print $1 }') >/dev/null 2>&1

	Logger info "Aborting IBFORMIX..."

	# Поскольку мы уже загрузили настройки пользователя informix,
	# делаем su без "-"
	# Имеем возможность следить за процессом останова, так как
	# запускаем его в фоновом режиме 
	su informix -c "${INFORMIXDIR}/bin/onmode -ky" &
	onmodePID=$!
	
	# Начинаем следить за завершением процессов СУБД

	# Переменная задает период мониторинга (в секундах)
	integer moi=5
	# Счетчик циклов мониторинга
	integer TIME_OUT_COUNTER
	# Вычисляем общее число циклов
	(( TIME_OUT_COUNTER = TIME_OUT / moi ))
	while (( ${TIME_OUT_COUNTER} != 0 ))
	do
		# В теле цикла просматриваем список процессов и,
		# если какой-нибудь завершился,
		# выкидываем его из списка
		
		# Ждем чуть-чуть
		sleep ${moi}
		# Удаляем пустые элементы массива
		set -A MONITOR_PROCESSES_PID ${MONITOR_PROCESSES_PID[*]}
		# Переменная p пробегает по списку pid'ов,
		# а переменная pp хранит номер текущего
		integer pp=0
		for p in ${MONITOR_PROCESSES_PID[*]}
		do
			# Есть ли такой процесс?
			kill -0 $p >/dev/null 2>&1
			if (( $? != 0 ))
			then
				# Процесса не найдено
				Logger debug "${MONITOR_PROCESS} (${p}) process has stopped."
				# Удаляем его pid из списка
				unset MONITOR_PROCESSES_PID[$pp]
			fi
			(( pp = pp + 1 ))
		done

		if [[ -z ${MONITOR_PROCESSES_PID[*]} ]]
		then
			# Массив пустой, все процессы завершились
			# Можно выходить, но сначала дождемся
			# завершения 'onmode'
			wait
			# Удаляем файл блокировки и выходим из программы
			Exit ${RetValue}
		fi

		(( TIME_OUT_COUNTER = TIME_OUT_COUNTER - 1 ))
	done

	# Время ожидания истекло, а процессы не умерли.
	# Убиваем их

	# Для начала сохраним список процессов
	PACKAGE_LOG_PS informix
	
	# Первым делом убиваем так называемый Master Daemon.
	# Для этого используем сигнал KILL (он игнорирует TERM).
	# Список процессов был составлен таким образом,
	# что этот Master Daemon идет первым номером
	kill -9 ${MONITOR_PROCESSES_PID[0]} >/dev/null 2>&1
	if (( $? = 0 ))
	then
		Logger notice "${Name} sent SIGKILL to Master Daemon (${MONITOR_PROCESSES_PID[0]})."
		# Прибили мы его и ждем, пока детки умрут
		sleep 30
	fi
	unset MONITOR_PROCESSES_PID[0]
	# Для верности, если остальные не отвалились,
	# убиваем всех по очереди 
	for p in ${MONITOR_PROCESSES_PID[*]}
	do
		# Цикл по всем процессам СУБД
		# Сначала посылаем сигнал TERM.
		kill $p >/dev/null 2>&1
		if (( $? = 0 ))
		then
			sleep 5
			# Сигнал, конечно, послан,
			# но процесс, скорее всего, его не обработает.
			# Поэтому добиваем его сигналом KILL.
			kill -9 $p >/dev/null 2>&1
			if (( $? = 0 ))
			then
				Logger notice \
					"${Name} sent SIGKILL to process ${p}."
			fi
		else
			# Оказывается этого процесса уже нет
			Logger debug \
				"${MONITOR_PROCESS} (${p}) process has stopped."
		fi
	done

	# Все процессы убили, пришел черед запущенной раннее команды onmode
	kill -9 ${onmodePID}
	# Возвращаем ошибку
	Exit 3
}

################################################################################
################################################################################
# Функция наблюдения за сервисом

################################################################################
# Процедура производит наблюдение за процессами СУБД INFORMIX.
# Перед началом работы строится список pid'ов процессов, в соответствии
# с которым после и будет проводится мониторинг и останов СУБД.
#
# Параметры:
#	нет
#
# Возвращаемые значения:
#	процедура не возвращает управление, она вызывает процедуру Halt_INFORMIX
#	или exit передавая им код ошибки.
#
# Используемае внешние функции:
#	PACKAGE_LOG_PS
#
# Используемае внешние переменные:
#	OLD_PROCESSES_PID -- заполняется в функции Start_INFORMIX
#
function Monitor_processes
{
	# Строим список MONITOR_PROCESSES_PID
	# Первый элемент списка -- pid процесса Master Daemon
	# запоминаем пока в отдельной переменной
	ParentPID=$(ps -lu informix | \
		awk -v Name="${MONITOR_PROCESS}"═\
			-v Exclude="${OLD_PROCESSES_PID}" \
			'$NF~"^"Name"$" && $5 == "1" && match (" "Exclude" " , " "$4" ") == 0
			{ # Ещем процесс, у которого родитель имеет pid равный 1,
			  # но который не входит в OLD_PROCESSES_PID
				print $4 }
			' )
	# Добавляем найденный pid в OLD_PROCESSES_PID,
	# чтобы не занести потом его в список во второй раз
	OLD_PROCESSES_PID="${ParentPID} ${OLD_PROCESSES_PID}"
	
	# Начинаем непосредственно строительство списка MONITOR_PROCESSES_PID
	set -A MONITOR_PROCESSES_PID $(ps -u informix | \
		awk -v Name="${MONITOR_PROCESS}" \
			-v Exclude="${OLD_PROCESSES_PID}" \
			'$4~"^"Name"$" && match (" "Exclude" " , " "$1" ") == 0
			{ # Ещем процесс, который не входит в OLD_PROCESSES_PID
				print $1 }
			' )
	# Добавляем ParentPID в массив MONITOR_PROCESSES_PID на первое место
	set -A MONITOR_PROCESSES_PID ${ParentPID} ${MONITOR_PROCESSES_PID[*]}
	unset ParentPID OLD_PROCESSES_PID
	
	# А есть ли вообще процессы?
	if [[ -z ${MONITOR_PROCESSES_PID[*]} ]]
	then
		# Ни одного нового процесса INFORMIX не появилось
		# Сохраняем список процессов
		PACKAGE_LOG_PS informix
		Logger alert "Process \"${MONITOR_PROCESS}\" has failed at startup time, ABORTING INFORMIX!"
		# Выходим с кодом ошибки
		exit 4
	fi

	# Разбиваем период мониторинга на более мелкие интервалы (MOI),
	# поскольку программа не может получить и обработать сигнал,
	# находясь во сне.
	integer MOI=10
	integer Counter

	# Входим в бесконечный цикл наблюдения.
	# Выход возможен только в случае сбоя СУБД.
	while true
	do
		# Спим, но ждем сигнала
		(( Counter = MONITOR_INTERVAL / MOI ))
		while (( ${Counter} != 0 ))
		do
			sleep ${MOI}
			(( Counter = Counter - 1 ))
		done

		# Проходим по всем процессам
		for pid in ${MONITOR_PROCESSES_PID[*]}
		do
			# В теле цикла проверяется наличие в системе процесса
			kill -0 ${pid} >/dev/null 2>&1
			if (( $? != 0 ))
			then
				# Процесса не обнаружено
				Logger err "Process \"${pid}\" has failed, aborting INFORMIX!"
				# Сохраняем список процессов
				PACKAGE_LOG_PS informix
				# Перед выходом хотим дать возможность СУБД
				# корректно завершить работу
				Halt_INFORMIX 5
			fi
		done
	done
}

################################################################################
################################################################################
#
# Перехватываем сигнал TERM -- при получении его программа останавливает СУБД
trap Halt_INFORMIX SIGTERM

# Запускаем СУБД...
Start_INFORMIX
# ... и начинаем наблюдение
Monitor_processes
Monitor_processes
