#!/usr/xpg4/bin/sh
# Version	2.3q
# Date		19 Dec 2001
# Author	Kirill Kartinkin

# Программа для перевода кластерного сервиса, представленного СУБД Oracle,
# из состояния SERVE в состояния STANDBY или OFFLINE.
#
# Работа программы гарантирована с СУБД версий выше 7.3.x.
#
# Программу требуется запускать от имени пользователя root.
#
# Внимание! Данная программа работает только совместно с Qualix и только в
# рамках группы сервисов.
#
# Программа пытается остановить СУБД командой 'shutdown immediate',
# в случае неудачи отдает команду 'shutdown abort' и,
# если это не помогло, убивает оставшиеся процессы.
#
# Параметры:
#	нет
#
# Возвращаемые значения:
#	0	O.K.
#	0	Oracle остановить не удалось, процессы убиты
#	100	Программу запустили не так
#	101	Ошибка подключения вспомогательных файлов

# Если эти переменные не описаны, значит нас запустили "руками"
# Переменная TOPDIR задает месторасположение Qualix HA+,
# например, /etc/opt/QUALha.
# Переменная SGNAME содержит имя сервисной группы
# Переменная SVCNAME содержит имя сервиса
if [[ -z ${TOPDIR} || -z ${SGNAME} || -z ${SVCNAME} ]]
then
	# Ошибка, переменные не описаны
	exit 100
fi

################################################################################
# Описываем переменные конфигурации и производим необходимые проверки

# Устанавливаем необходимые пути поиска
PATH=/sbin:/usr/sbin:/usr/xpg4/bin:/usr/bin:/var/adm/bin

# Строим расширенное имя программы
Name=${SGNAME}.${SVCNAME}.${0##*/}

# Внимание! Для работы программы необходимы следующие файлы:
set -A FilesToSource \
	${TOPDIR}/sg/${SGNAME}/${SVCNAME}.d/environment \
	'~${OracleUser}/.${SVCNAME}.environment' \
	${TOPDIR}/sg/${SGNAME}/${SVCNAME}.d/configure \
	/var/adm/bin/logger.sh
	
# В файле ${TOPDIR}/sg/${SGNAME}/${SVCNAME}.d/environment содержатся
# основные настроечные параметры пакета.
#	ShutdownTimeOut
#	AbortTimeOut
#	OracleUser
#	TestStatement
#	TestString
#	TestUser
#	SGFacility
#
# В файле ~${OracleUser}/.${SGNAME}.environment содержатся все необходимые
# администратору СУБД переменные окружения.
#	ORACLE_HOME
#	ORACLE_SID
#	PATH=${ORACLE_HOME}/bin:${PATH}
#	и прочие
#
# В файле ${TOPDIR}/sg/${SVCNAME}/${SVCNAME}.d/configure содержатся
# переменные окружения для пакета.
#	DevDir
#	PIDsFile
#	MonitorProcess
#	ProcessName
#	PFile
#	SGA
#	OracleMgrl
#	SQLPlus
#
# Файле /var/adm/bin/logger.sh содержит функцию Logger
# Следующие переменные необходимы для описания этой функции.
# При описании используем одинарные кавычки, чтобы передать имя переменной
# окружения, а не ее значение.
LOGGER_FACILITY='${SGFacility}'
LOGGER_TAG=${SGNAME}

# Добавляем указанные выше файлы
for File in ${FilesToSource[*]}
do
	eval File=${File}
	eval File=${File}
	if [[ -f ${File} ]]
	then
		. ${File}
	else
		print "${Name}:\tERROR: Unnable to source ${File}"
		exit 101
	fi
done

################################################################################
################################################################################
# В зависимости от ситуации СУБД останавливается и оставляет БД в
# состоянии логической целестности (shutdown immediate)
# или прекращает обработку запросов немедленно (shutdown abort).
#
# Если за определенные период времени СУБД не остановилась,
# ее процессы убиваются.
	
# Переменная указывает на успешное замершение процесса останова
Shuted="No"
	
################################################################################
# Стандартное завершение
# Стараемя коректно закрыть БД
Logger info "Shuting down Oracle..."

# Поскольку мы уже загрузили настройки пользователя ${OracleUser},
# делаем su без "-"
# Имеем возможность следить за процессом останова, так как
# запускаем его в фоновом режиме 
(	print "connect internal;\nshutdown immediate;\nexit;" | \
		su ${OracleUser} -c "${OracleMgrl}"
	if (( $? != 0 ))
	then
		Logger err "Oracle shutdown failed!"
	else
		Logger info "Oracle shuted down."
	fi )&
ShutdownPID=$!

# Начинаем следить за завершением процесса закрытия БД
# Если за определенное время он не завершится,
# идем на shutdown abort

# Переменная задает период мониторинга (в секундах)
integer moi=5
# Счетчик циклов мониторинга
integer TimeoutCounter
# Вычисляем общее число циклов
(( TimeoutCounter = ShutdownTimeOut / moi ))
while (( ${TimeoutCounter} != 0 ))
do
	# В теле цикла приглядываем за процессом ShutdownPID
	# Ждем чуть-чуть
	sleep ${moi}
	# Есть ли такой процесс?
	kill -0 ${ShutdownPID} >/dev/null 2>&1
	if (( $? != 0 ))
	then
		# Процесса не найдено
		# Подтвержнаем останов, выходим из цикла
		Shuted="Yes"
		break
	fi
	(( TimeoutCounter = TimeoutCounter - 1 ))
done

################################################################################
# Проверяем, отработала ли команда на shutdown
if [[ ${Shuted} = "No" ]]
then
	# Сюда попадаем если не удалось выполнить 'shutdown immediate'
	Logger info "Aborting Oracle..."

	# Поскольку мы уже загрузили настройки пользователя ${OracleUser},
	# делаем su без "-"
	# Имеем возможность следить за процессом останова, так как
	# запускаем его в фоновом режиме 
	(	print "connect internal;\nshutdown abort;\nexit;" | \
			su ${OracleUser} -c "${OracleMgrl}"
		if (( $? != 0 ))
		then
			Logger err "Oracle abort failed!"
		else
			Logger info "Oracle abort done."
		fi )&
	AbortPID=$!
fi
	
# Начинаем следить за завершением процессов СУБД

# Считываем список pid'ов процессов, созданный для нас при старте.
set -A MonitorProcessesPIDs $(cat ${PIDsFile})

# Переменная задает период мониторинга (в секундах)
integer moi=5
# Счетчик циклов мониторинга
# Вычисляем общее число циклов
(( TimeoutCounter = AbortTimeOut / moi ))
while (( ${TimeoutCounter} != 0 ))
do
	# В теле цикла просматриваем список процессов и,
	# если какой-нибудь завершился,
	# выкидываем его из списка
	
	# Ждем чуть-чуть
	sleep ${moi}
	# Удаляем пустые элементы массива
	set -A MonitorProcessesPIDs ${MonitorProcessesPIDs[*]}
	# Переменная p пробегает по списку pid'ов,
	# а переменная i хранит номер текущего
	integer i=0
	for p in ${MonitorProcessesPIDs[*]}
	do
		# Есть ли такой процесс?
		kill -0 $p >/dev/null 2>&1
		if (( $? != 0 ))
		then
			# Процесса не найдено
			Logger debug "${ProcessName[$i]} (${p}) process has stopped."
			# Удаляем его pid из списка
			unset MonitorProcessesPIDs[$i]
		fi
		(( i = i + 1 ))
	done

	if [[ -z ${MonitorProcessesPIDs[*]} ]]
	then
		# Массив пустой, все процессы завершились
		# Можно выходить, но сначала дождемся
		# завершения 'shutdown abort'
		wait
		exit 0
	fi

	(( TimeoutCounter = TimeoutCounter - 1 ))
done

################################################################################
# Время ожидания истекло, а процессы не умерли.
# Убиваем их

# Для начала сохраним список процессов
ps -ef
	
# Убиваем всех по очереди 
for p in ${MonitorProcessesPIDs[*]}
do
	# Цикл по всем процессам СУБД
	# Сначала посылаем сигнал TERM.
	kill $p >/dev/null 2>&1
	if (( $? == 0 ))
	then
		sleep 5
		# Сигнал, конечно, послан,
		# но процесс, скорее всего, его не обработает.
		# Поэтому добиваем его сигналом KILL.
		kill -9 $p >/dev/null 2>&1
		if (( $? == 0 ))
		then
			Logger notice \
				"${Name} sent SIGKILL to process ${p}."
		fi
	else
		# Оказывается, этого процесса уже нет.
		Logger debug "${p} process has stopped."
	fi
done

# Все процессы убили, пришел черед запущенных раннее команд останова
kill -9 ${ShutdownPID} ${AbortPID} >/dev/null 2>&1
# Возвращаем ошибку
exit 0
