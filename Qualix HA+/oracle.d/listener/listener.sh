#!/usr/bin/sh
# Version	0.0
# Date		3 Dec 99
# Author	Kirill Kartinkin

# Управляющая программа кластерного сервиса, представленного
# демоном listener к СУБД Oracle.
# Предполагается, что программа хранится в директории /etc/cmcluster/bin,
# а в директории /etc/cmcluster/ИмяПакета находится ссылка.
# Исходя из имени директории ИмяПакета строятся имена конфигурационных
# и временных файлов.
#
# Работа программы гарантирована с СУБД версий выше 7.3.3. Доподлинно известно,
# что она не поддерживает Oracle до версии 7.3.3.
#
# Внимание! Данная программа работает только совместно с MC/ServiceGuard и
# только в рамках пакета. Более того, она использует нестандартные возможности
# программы управления пакетом (написанные автором) и может работать только в
# такой расширенной среде.
# Программу требуется запускать от имени пользователя root.
#
# При запуске программы производятся последовательно следующие действия:
#	Подключаются все необходимые конфигурационные файлы.
#	Запускается listener.
#	Начинается слежение за работой демона.
# Если демон вдруг исчез, программа пытается остановить его.
#
# Когда программа получает сигнал TERM, производится останов демона и,
# в случае неудачи, он убивается.
#
# Параметры:
#	нет
#
# Возвращаемые значения:
#	0	O.K.
#	2	Listener не запушен
#	3	Listener остановить не удалось, процессы убиты
#	4	Listener свалился сразу после старта
#	5	Listener свалился во время работы
#	10	Сигнал на останов пришел слишком рано
#	101	Ошибка подключения вспомогательных файлов
#

################################################################################
# Описываем переменные конфигурации и производим необходимые проверки

# Устанавливаем необходимые пути поиска
PATH=/sbin:/usr/sbin:/usr/bin

# Извлекаем из командной строки имя программы
Name=${0##*/}
# Извлекаем из командной строки путь
Path=${0%/*}
# Получаем имя пакета
Package=${Path##*/}

# Внимание! Для работы программы необходимы следующие файлы:
set -A FilesToSource \
	~oracle/.${Package}.environment \
	/etc/cmcluster/etc/packages.environment \
	/var/adm/bin/logger.sh
	
# В файле ~oracle/.${Package}.environment содержатся все необходимые
# администратору СУБД переменные окружения.
#	ORACLE_HOME
#	ORACLE_SID

# В файле /etc/cmcluster/etc/packages.environment содержатся
# переменные окружения для пакета.
#	LOCK_FILE
#	PACKAGE_FACILITY
#	PACKAGE_LOG_PS
#	TouchLock
#	RemoveLock
#	Exit

# Файле /var/adm/bin/logger.sh содержит функцию Logger
# Следующие переменные необходимы для описания этой функции.
# При описании используем одинарные кавычки, чтобы передать имя переменной
# окружения, а не ее значение.
LOGGER_FACILITY='${PACKAGE_FACILITY}'
LOGGER_TAG=${Package}

# Добавляем указанные выше файлы
for File in ${FilesToSource[*]}
do
	if [[ -r ${File} ]]
	then
		. ${File}
	else
		print "${Name}:\tERROR: Unnable to source ${File}"
		exit 101
	fi
done

# Переменная задает имена имя демона liestener.
MONITOR_PROCESS="tnslsnr"

# Переменная содержит период (в секундах) проверки состояния СУБД.
# Значение должно быть больше 10 секунд.
MONITOR_INTERVAL=300

# Промежуток времени (в секундах) в течениии которого мы ждем завершения
# работы демона. По истечении заданного времени он убивается.
#
# Внимание! Данное значение должно быть на минуту меньше таймаута,
# установленного в конфигурации пакета для этого сервиса.
TIME_OUT=20

################################################################################
################################################################################
# Функция для запуска сервиса

################################################################################
# Функция стартует listenet для СУБД Oracle версии 7.3.3.
#
# Параметры:
#	нет
#
# Возвращаемые значения:
#	0 -- демон запущена
#	если запуск демона невозможен, вызывается функция Exit
#
function StartListener
{
	# Устанавливаем блокировку
	TouchLock

	Logger info "Starting listener sid ${ORACLE_SID}..."

	# Поскольку мы уже загрузили настройки пользователя oracle,
	# делаем su без "-"
	print "start ${ORACLE_SID}\nexit" | \
		su oracle c "${ORACLE_HOME}/bin/lsnrctl"
	if (( $? != 0 ))
	then
		Logger err "Listener NOT started!"
		Exit 2
	else
		Logger info "Listener started!"
	fi
	# Удаляем файл блокировок
	RemoveLock
}

################################################################################
################################################################################
# Функции для останова сервиса

################################################################################
# Процедура останавливает listener СУБД Oracle версии 7.3.3.
# В зависимости от ситуации СУБД останавливается и оставляет БД в
# состоянии логической целестности (shutdown immediate)
# или прекращает обработку запросов немедленно (shutdown abort).
#
# Если за определенные период времени listener не остановился,
# он убивается.
#
# Параметры:
#	$1 -- код возврата (позволяет указать в какой ситуации вызвали функцию).
#		Если параметр не указан, код возврата становится 0.
#		Отличное от нуля значение говорит о сбое в работе демона и
#		необходимости аварийной остановки.
#
# Возвращаемые значения:
#	процедура не возвращает управление, она вызывает процедуру Exit
#	передавая ей значение параметра $1 или 0, если последний не указан.
#
# Используемае внешние функции:
#	PACKAGE_LOG_PS
#
# Используемые внешние переменные:
#	MONITOR_PROCESSES_PID -- заполняется функцией MonitorProcesses
#
function AbortListener
{
	# Проверяем параметр и устанавливаем код возврата
	if [[ -z $1 ]]
	then
		RetValue=0
	else
		RetValue=$1
	fi
	
	# Устанавливаем блокировку
	TouchLock

	# Проверяем, создан ли список процессов (может случится так, что
	# сигнал TERM получен до заполнения массива).
	if [[ -z ${MONITOR_PROCESSES_PID[*]} ]]
	then
		Logger err "Program terminated to early."
		Exit 10
	fi

	# Стандартное завершение
	Logger info "Shuting down Listener sid ${ORACLE_SID}..."

	# Поскольку мы уже загрузили настройки пользователя oracle,
	# делаем su без "-"
	# Имеем возможность следить за процессом останова, так как
	# запускаем его в фоновом режиме 
	( print "stop ${ORACLE_SID}\nexit" | \
		su oracle -c "${ORACLE_HOME}/bin/lsnrctl"
	if (( $? != 0 ))
	then
		ShutdownErr=$?
		Logger err "Listener shutdown failed!"
	else
		Logger info "Listener shuted down!"
	fi )&
	ShutdownPID=$!

	# Начинаем следить за завершением процесса

	# Переменная задает период мониторинга (в секундах)
	integer moi=5
	# Счетчик циклов мониторинга
	# Вычисляем общее число циклов
	(( TimeoutCounter = TIME_OUT / moi ))
	while (( ${TimeoutCounter} != 0 ))
	do
		# В теле цикла просматриваем список процессов и,
		# если какой-нибудь завершился,
		# выкидываем его из списка
		
		# Ждем чуть-чуть
		sleep ${moi}
		# Удаляем пустые элементы массива
		set -A MONITOR_PROCESSES_PID ${MONITOR_PROCESSES_PID[*]}
		# Переменная p пробегает по списку pid'ов,
		# а переменная pp хранит номер текущего
		integer pp=0
		for p in ${MONITOR_PROCESSES_PID[*]}
		do
			# Есть ли такой процесс?
			kill -0 $p >/dev/null 2>&1
			if (( $? != 0 ))
			then
				# Процесса не найдено
				Logger debug "Process \"${MONITOR_PROCESS}\" (${p}) process has stopped."
				# Удаляем его pid из списка
				unset MONITOR_PROCESSES_PID[$pp]
			fi
			(( pp = pp + 1 ))
		done

		if [[ -z ${MONITOR_PROCESSES_PID[*]} ]]
		then
			# Массив пустой, все процессы завершились
			# Можно выходить, но сначала дождемся
			# завершения команды 'stop'
			wait
			# Удаляем файл блокировки и выходим из программы
			Exit ${RetValue}
		fi

		(( TimeoutCounter = TimeoutCounter - 1 ))
	done

	# Время ожидания истекло, а процессы не умерли.
	# Убиваем их

	# Для начала сохраним список процессов
	PACKAGE_LOG_PS listener_${ORACLE_SID}
	
	# Убиваем всех по очереди 
	for p in ${MONITOR_PROCESSES_PID[*]}
	do
		# Цикл по всем процессам.
		# Сначала посылаем сигнал TERM.
		kill $p >/dev/null 2>&1
		if (( $? = 0 ))
		then
			sleep 5
			# Сигнал, конечно, послан,
			# но процесс, скорее всего, его не обработает.
			# Поэтому добиваем его сигналом KILL.
			kill -9 $p >/dev/null 2>&1
			if (( $? = 0 ))
			then
				Logger notice \
					"${Name} sent SIGKILL to process ${p}."
			fi
		else
			# Оказывается этого процесса уже нет
			Logger debug "(${p}) process has stopped."
		fi
	done

	# Все процессы убили, пришел черед запущенной раннее команды останова
	kill -9 ${ShutdownPID}
	# Возвращаем ошибку
	Exit 3
}

################################################################################
################################################################################
# Функция наблюдения за сервисом

################################################################################
# Процедура производит наблюдение за процессами СУБД Oracle.
# Перед началом работы строится список pid'ов процессов, в соответствии
# с которым после и будет проводится мониторинг и останов СУБД.
#
# Параметры:
#	нет
#
# Возвращаемые значения:
#	процедура не возвращает управление, она вызывает процедуру AbortOracle
#	или exit передавая им код ошибки.
#
# Используемае внешние функции:
#	PACKAGE_LOG_PS
#
# Изменяемые внешние переменные
#	MONITOR_ROCESSES_PID
function MonitorProcesses
{
	# Строим список MONITOR_PROCESSES_PID
    set -A MONITOR_PROCESSES_PID $(ps -fu oracle | \
		grep "${MONITOR_PROCESS} ${ORACLE_SID} -inherit" | \
		awk '{ print $2 }' )

    if [[ -z ${MONITOR_PROCESSES_PID[*]} ]]
   	then
		# Процесса не обнаружено
		Logger alert "Listener has failed at startup time!"
		# Сохраняем список процессов
		PACKAGE_LOG_PS listener_${ORACLE_SID}
		# Выходим с кодом ошибки
		AbortListener 4
	fi 

	# Разбиваем период мониторинга на более мелкие интервалы (MOI),
	# поскольку программа не может получить и обработать сигнал,
	# находясь во сне.
	integer MOI=10
	integer Counter

	# Входим в бесконечный цикл наблюдения.
	# Выход возможен только в случае сбоя СУБД.
	while true
	do
		# Спим, но ждем сигнала
		(( Counter = MONITOR_INTERVAL / MOI ))
		while (( ${Counter} != 0 ))
		do
			sleep ${MOI}
			(( Counter = Counter - 1 ))
		done

		# Проходим по всем процессам
		i=0
		for pid in ${MONITOR_PROCESSES_PID[*]}
		do
			# В теле цикла проверяется наличие в системе процесса
			kill -0 ${pid} >/dev/null 2>&1
			if (( $? != 0 ))
			then
				# Процесса не обнаружено
				Logger err "Process \"${MONITOR_PROCESS}\" (${pid}) has failed, aborting listener!"
				# Сохраняем список процессов
				PACKAGE_LOG_PS listener_${ORACLE_SID}
				# Перед выходом хотим дать возможность
				# корректно завершить работу
				AbortListener 5
			fi
			(( i = i + 1 ))
		done
	done
}

################################################################################
################################################################################
#
# Перехватываем сигнал TERM -- при получении его программа останавливает СУБД
trap AbortListener SIGTERM

# Запускаем демон...
StartListener
# ... и начинаем наблюдение
MonitorProcesses
MonitorProcesses
