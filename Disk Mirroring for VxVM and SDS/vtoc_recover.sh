#!/usr/bin/ksh -p
# 	0.0
# Date		26 Jul 2004
# Author	Kirill Kartinkin

# Программа предназначена для поиска файловых систем UFS на диске
# с утерянной таблицей разделов.
#
# Программа сканирует диск цилиндр за цилиндром, пытаясь найти первый и
# резервный суперблоки, если они содержат осмысленную информацию, выдается
# вопрос запоминать или нет ФС с указанием размера и точки последнего
# монтирования. При получении положительного ответа происходит перескок на
# первый за ФС цилиндр и сканирование продолжается.
#
# По окончании сканирования на диск записывается новая таблица разделов
# и проводится попытка запустить fsck на все найденные ФС.
#
# Параметры:
#	ИмяДиска -- имя диска сканируемого диска (вида cXtXdX)
# 
# Возвращаемые значения:
#	0	O.K.
#	1	Пользователь прервал работу
#	3	Не найдено диска
#	100	Ошибки в параметрах командной строки

################################################################################
# Описываем переменные конфигурации и производим необходимые проверки
Name=${0##*/}
PATH=/usr/bin:/usr/sbin

TempFile=/tmp/vtocrec.$$

################################################################################
# Разбираем параметры командной строки
if (( $# == 0 ))
then
	print "Usage: ${Name} cXtXdX -d"
	exit 100
else
	Disk=$1
fi

################################################################################
# Описываем вспомогательные функции

# Функция производит проверку кода возврата,
# если произошла ошибка -- выводится сообщение об ошибке и 
# осуществляется выход из программы.
#
# Параметры:
#	$1	код возврата в случае ошибки
# 	$2	сообщение об ошибке
#
function CheckRet
{
	if (( $? != 0 ))
	then
		# Код возврата не 0, выводим 
		print "Unnable to $2."
		if [[ -z ${Debug} ]]
		then
			exit $1
		else
			print "Debug mode:"
			/usr/bin/ksh -o emacs
		fi
	fi
}	

# Функция является обвязкой к программе ckyorn
# При ответе "Да" возвращает 0, "нет" -- 1. 
#
# Параметры:
#	$1	Текст вопроса
#
function Prompt
{
	case $(ckyorn -p "$*") in
		"y"|"Y") return 0 ;;
		"q"|"Q")
			rm ${TempFile}
			exit 1 ;;
		*) return 1 ;;
	esac
}

if [[ $2 == "-d" ]]
then
	Debug="Debug"
else
	Debug=""
fi

################################################################################
################################################################################

# Изучаем геометрию диска
Out=$(format </dev/null)
# Ищем строку с именем диска
DiskDescr=$(print "$Out" | nawk -F"<" -v Disk=${Disk} '$1~Disk { print $2 }')
if [[ -z ${DiskDescr} ]]
then
	# Описания диска не нашли, обидно
	print "\nDisk ${Disk} not found."
	exit 3
fi

# Вычисляем размер цилиндра, умножив число головок на число секторов
# Получаем число цилиндров.
set -A Sizes $(print ${DiskDescr} | nawk '{ print $NF*$(NF-2)" "$(NF-6)}')
CylSize=${Sizes[0]}
Cyls=${Sizes[1]}
unset Sizes
print "Disk has ${Cyls} cylinders, cylinder size is ${CylSize} blocks.\n"

# Запоминаем VTOC, из него нам понадобится второй раздел
VTOC=$(prtvtoc -h /dev/dsk/${Disk}s2 | awk '$1=="2" { print ; exit }')

# В цикле проходим по всем цилиндрам (переменная Cyl),
# в начале каждого ищем признаки суперблоков.
# Если находим ФС, создаем раздел под нее.
integer Cyl=0
# В переменной i сохраняется текущий раздел.
integer i=0

while (( ${Cyl} < ${Cyls} ))
do
	# Новый цилиндр
	echo "\r${Cyl}\c"

	# Нам нужны 16-31 и 32-47 блоки (первый и резервный суперблоки).
	# Запоминаем во временный файл соответствующий кусок.
	dd if=/dev/dsk/${Disk}s2 of=${TempFile} iseek=$((Cyl*CylSize+16)) bs=512 count=32 2>/dev/null
	
	# Ищем магические цифирки.
	set -A Magics $(od -t x1 ${TempFile} | \
		nawk 'NF>3 && $(NF-2)=="01" && $(NF-1)=="19" && $NF=="54" { print $1 }')
	# Для UFS они должны быть вот по таким адресам
	if [[ "${Magics[0]}" == "0002520" &&  "${Magics[1]}" == "0022520" ]]
	then
		# Нашли, наверно, UFS
		# Смотрим, в данном смещении сохраняется точка последнего монтирования
		FS=$(od -c -j 212 ${TempFile} | head -2 | cut -b8-72 | sed -e 's/  \\0//g')
		FS=$(print $FS | sed -e 's/ //g')
		# А это размер файловой системы из первого суперблока
		Sz1=$(od -t u4 -j 36 ${TempFile} | awk '{ print $2; exit}')
		# А это -- из второго
		Sz2=$(od -t u4 -j 8228 ${TempFile} | awk '{ print $2; exit}')
		# Проверяем, совпадают ли размеры
		if (( ${Sz1} == ${Sz2} ))
		then
			# Да, с высокой степенью вероятности это целая ФС
		    # Вычисляем размер в цилиндрах, чтобы их не сканировать
			(( Sz2 = Sz1 / CylSize * 2))

			# Окончательное решения за пользователем
			Prompt "Starting cylinder ${Cyl}, size $((Sz1/1024)) Mb (${Sz2} cyls), last mounted on ${FS}.\nIs it true?"
			if (( $? == 0 ))
			then
				# Пользователь согласился
				# Генерируем новый раздел в VTOC 
				VTOC="${VTOC}\n$i 0 00 $((Cyl*CylSize)) $((Sz1*2)) $((Cyl*CylSize+Sz1*2-1))"
				# Увеличиваем i на единицу перескакивая через 2
				if (( $i == 1 ))
				then
					i=3
				else
					(( i = i + 1 ))
				fi
				# Чтобы не сканировать цилиндры с ФС,
				# сразу прыгаем на ее последний цилиндр
				(( Cyl = Cyl + Sz2 - 1 ))
				# сразу прыгаем за ее последний цилиндр
				#(( Cyl = Cyl + Sz2 ))
				print "Jumping to cylinder ${Cyl}."
			fi
		fi
	fi
	# Переходм к следующему цилиндру
	(( Cyl = Cyl + 1 ))
done

# Распечатываем VTOC
Prompt "Apply this VTOC:\n${VTOC}\n ?"
if (( $? == 0 ))
then
	# Подтверждение получено,
	# записываем новую таблицу разделов
	print "${VTOC}" | fmthard -s - /dev/rdsk/${Disk}s2
	prtvtoc -h /dev/rdsk/${Disk}s2

	# По всем новым разделам прогоняем fsck
	(( i = i - 1 ))
	while (( i >= 0 ))
	do
		if (( $i != 2 ))
		then
			print "\nStarting fsck on slice $i:"
			fsck -NF ufs /dev/dsk/${Disk}s${i}
		fi
		(( i = i - 1 ))
	done
fi

rm ${TempFile} 2>/dev/null
exit 0
